> Encoding and Evolution
> 데이터 부호화를 위한 다양한 형식으로 스키마가 변경되고 예전 버전과 새로운 버전의 데이터와 코드가 공존하는 시스템을 어떻게 지원하는지 알아보자.

- 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 상위 호환성: 에전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.

## 1. 데이터 부호화 형식
- 프로그램은 최소한 두 가지 형태로 표현된 데이터를 사용해 동작
	- 객체, 구조체, 목록, 배열, 해시, 트리 등등
	- CPU에서 효율적으로 접근하고 조작할 수 있도록 최적화
- 데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 바이트열 형태로 부호화 해야함
- 인 메모리 -> 바이트열: 부호화, 직렬화, 마샬링
- 바이트열 -> 인 메모리: 복호화, 역질렬화, 역마샬링, 파싱
- [바이트열 (바이트 순서 표식)](https://ko.wikipedia.org/wiki/%EB%B0%94%EC%9D%B4%ED%8A%B8_%EC%88%9C%EC%84%9C_%ED%91%9C%EC%8B%9D
)

### 1.1. 언어별 형식
- 많은 프로그래밍 언어는 인 메모리 객체를 바이트열로 부호화하는 기능을 내장
	- 자바: java.io.Serializable
	- 루비: Marshal
	- 파이썬: pickle
- 문제점
	- 부호화는 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 읽기 어려움
	- 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야하는데 종종 보안 문제의 원인이 됨
	- 데이터 버전 관리의 어려움
	- 효율성

### 1.2. JSON과 XML, 이진 변형
- XML은 너무 장황하고 불필요하게 복잡하여 비판 받음
- JSON은 자바스크립트의 지원과 단순하여 많이 사용됨
- 둘다 텍스트 형식으로 사람이 읽을 수 있음
- 문제점
	- 수(number) 부호화에 대한 애매함
		- JSON은 정수와 부동소수점을 구별하지 않고 정밀도를 지정하지 않음
		- 2^53 보다 큰 정수는 [IEEE 754 배정도 수](https://ko.wikipedia.org/wiki/IEEE_754) 에서 정확하게 표현할 수 없으므로 이런 수는 파싱할 때 부정확해질 수 있음
	- 유니코드는 잘 지원하나 바이트는 지원하지 않음
		- Base64 인코딩으로 제한을 피하는 방법이 있지만 정공법은 아니고 데이터 크기가 증가함
	- 필수는 아니지만 스키마를 지원하지만 구현하기가 상당히 난해함

### 1.3. 이진 부호화
- 조직 내에서만 사용하는 데이터라면 최소공통분모 부호화 형식을 사용해야하는 부담감이 덜함
- XML은 장황하고, JSON은 이진 형식에 비해 많은 공간을 사용하여 각 포맷에 사용가능한 이진 부호화가 개발됨
	- JSON: 메시지팩, BSON, BJSON, UBJSON, BISON, 스마일 등
	- XML: WBXML, 패스트 인포셋
	- 틈새 시장에 채택되었으나 널리 채택되지는 않음
- 데이터타입 셋을 확장했지만 데이터 모델은 변경하지 않고 유지

### 1.4. 스리프트와 프로토콜 버퍼
- 스리프트와 프로토콜 버퍼 모두 부호화할 데이터를 위한 스키마가 필요
- 스키마를 각 라이브러리에 해당하는 형식으로 작성하고 다양한 프로그래밍 언어로 변환한 클래스를 생성하여 어플리케이션에서 부호화/복호화가 가능
- JSON을 이진 부호화한 메시지 팩보다 더 다양한 형식으로 부호화가 가능

#### 1.4.1. 필드 태그와 스키마 발전
- 
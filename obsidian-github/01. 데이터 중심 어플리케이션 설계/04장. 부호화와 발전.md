> Encoding and Evolution
> 데이터 부호화를 위한 다양한 형식으로 스키마가 변경되고 예전 버전과 새로운 버전의 데이터와 코드가 공존하는 시스템을 어떻게 지원하는지 알아보자.

- 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 상위 호환성: 에전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.

## 1. 데이터 부호화 형식
- 프로그램은 최소한 두 가지 형태로 표현된 데이터를 사용해 동작
	- 객체, 구조체, 목록, 배열, 해시, 트리 등등
	- CPU에서 효율적으로 접근하고 조작할 수 있도록 최적화
- 데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 바이트열 형태로 부호화 해야함
- 인 메모리 -> 바이트열: 부호화, 직렬화, 마샬링
- 바이트열 -> 인 메모리: 복호화, 역질렬화, 역마샬링, 파싱
- [바이트열 (바이트 순서 표식)](https://ko.wikipedia.org/wiki/%EB%B0%94%EC%9D%B4%ED%8A%B8_%EC%88%9C%EC%84%9C_%ED%91%9C%EC%8B%9D
)

### 1.1. 언어별 형식
- 많은 프로그래밍 언어는 인 메모리 객체를 바이트열로 부호화하는 기능을 내장
	- 자바: java.io.Serializable
	- 루비: Marshal
	- 파이썬: pickle
- 문제점
	- 부호화는 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 읽기 어려움
	- 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야하는데 종종 보안 문제의 원인이 됨
	- 데이터 버전 관리의 어려움
	- 효율성

### 1.2. JSON과 XML, 이진 변형
- XML은 너무 장황하고 불필요하게 복잡하여 비판 받음
- JSON은 자바스크립트의 지원과 단순하여 많이 사용됨
- 둘다 텍스트 형식으로 사람이 읽을 수 있음
- 문제점
	- 수(number) 부호화에 대한 애매함
		- JSON은 정수와 부동소수점을 구별하지 않고 정밀도를 지정하지 않음
		- 2^53 보다 큰 정수는 [IEEE 754](https://ko.wikipedia.org/wiki/IEEE_754) 에서 정확하게 표현할 수 없으므로 이런 수는 
 

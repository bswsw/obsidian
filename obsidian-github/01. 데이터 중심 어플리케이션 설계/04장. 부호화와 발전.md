> Encoding and Evolution
> 데이터 부호화를 위한 다양한 형식으로 스키마가 변경되고 예전 버전과 새로운 버전의 데이터와 코드가 공존하는 시스템을 어떻게 지원하는지 알아보자.

- 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 상위 호환성: 에전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.

## 1. 데이터 부호화 형식
- 프로그램은 최소한 두 가지 형태로 표현된 데이터를 사용해 동작
	- 객체, 구조체, 목록, 배열, 해시, 트리 등등
	- CPU에서 효율적으로 접근하고 조작할 수 있도록 최적화
- 데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 바이트열 형태로 부호화 해야함
- 인 메모리 -> 바이트열: 부호화, 직렬화, 마샬링
- 바이트열 -> 인 메모리: 복호화, 역질렬화, 역마샬링, 파싱
- [바이트열 (바이트 순서 표식)](https://ko.wikipedia.org/wiki/%EB%B0%94%EC%9D%B4%ED%8A%B8_%EC%88%9C%EC%84%9C_%ED%91%9C%EC%8B%9D)

### 1.1. 언어별 형식
- 많은 프로그래밍 언어는 인 메모리 객체를 바이트열로 부호화하는 기능을 내장
	- 자바: java.io.Serializable
	- 루비: Marshal
	- 파이썬: pickle
- 문제점
	- 부호화는 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 읽기 어려움
	- 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야하는데 종종 보안 문제의 원인이 됨
	- 데이터 버전 관리의 어려움
	- 효율성

### 1.2. JSON과 XML, 이진 변형
- XML은 너무 장황하고 불필요하게 복잡하여 비판 받음
- JSON은 자바스크립트의 지원과 단순하여 많이 사용됨
- 둘다 텍스트 형식으로 사람이 읽을 수 있음
- 문제점
	- 수(number) 부호화에 대한 애매함
		- JSON은 정수와 부동소수점을 구별하지 않고 정밀도를 지정하지 않음
		- 2^53 보다 큰 정수는 [IEEE 754 배정도 수](https://ko.wikipedia.org/wiki/IEEE_754) 에서 정확하게 표현할 수 없으므로 이런 수는 파싱할 때 부정확해질 수 있음
	- 유니코드는 잘 지원하나 바이트는 지원하지 않음
		- Base64 인코딩으로 제한을 피하는 방법이 있지만 정공법은 아니고 데이터 크기가 증가함
	- 필수는 아니지만 스키마를 지원하지만 구현하기가 상당히 난해함

### 1.3. 이진 부호화
- 조직 내에서만 사용하는 데이터라면 최소공통분모 부호화 형식을 사용해야하는 부담감이 덜함
- XML은 장황하고, JSON은 이진 형식에 비해 많은 공간을 사용하여 각 포맷에 사용가능한 이진 부호화가 개발됨
	- JSON: 메시지팩, BSON, BJSON, UBJSON, BISON, 스마일 등
	- XML: WBXML, 패스트 인포셋
	- 틈새 시장에 채택되었으나 널리 채택되지는 않음
- 데이터타입 셋을 확장했지만 데이터 모델은 변경하지 않고 유지

- 부호화 대상 예제
```json
{
	"userName": "Martin",
	"favoritNumber": 1337,
	"interests": ["daydreaming", "hacking"]
}
```

### 1.4. 스리프트와 프로토콜 버퍼
- 스리프트와 프로토콜 버퍼 모두 부호화할 데이터를 위한 스키마가 필요
- 스키마를 각 라이브러리에 해당하는 형식으로 작성하고 다양한 프로그래밍 언어로 변환한 클래스를 생성하여 어플리케이션에서 부호화/복호화가 가능
- JSON을 이진 부호화한 메시지 팩보다 더 다양한 형식으로 부호화가 가능

- 스리프트
	- 바이너리 프로토콜
		- 59 바이트
		- 필드 타입 주석
		- 길이 주석
		- 문자열 ASCII 또는 UTF-8 부호화
		- 필드 이름은 없고 필드 태그
	- 컴팩트 프로토콜
		- 34 바이트
		- 필드 타입과 태그 숫자를 바이트로 줄임
		- 가변 길이 정수를 사용해서 부호화
			- 1337: 8바이트 -> 2바이트
		- 각 바이트의 상위 비트는 앞으로 더 많은 바이트가 있는지 나타냄
			- -64 ~ 63: 1바이트 부호화
			- -8192 ~ 8191: 2바이트 부호화
- 프로토콜 버퍼
	- 33 바이트
	- 컴팩트 프로토콜과 비슷
	- required, optional, repeated 등 키워드가 존재함

#### 1.4.1. 필드 태그와 스키마 발전
- 각 필드는 태그 숫자로 식별하고 데이터 타입을 주석으로 작성
- 필드 값을 설정하지 않은 경우는 부호화 레코드에서 생략
- 부호화된 데이터는 필드 이름을 전혀 참조하지 않기 때문에 스키마에서 필드 이름은 변경할 수 있음
- 필드 태그는 모든 부호화된 데이터를 인식 불가능하게 만들 수 있기 때문에 변경할 수 없음
- 새로운 태그 번호를 부여하는 방식으로 새로운 필드 추가 가능
- 예전 코드에서 새로운 코드로 기록한 데이터를 읽으려는 경우 해당 필드를 무시할 수 있음
- 데이터 타입 주석은 파서가 몇 바이트를 건너뛸수 있는지 알려줘 상위 호환성을 유지함
- 각 필드에 고유한 태그 번호가 있으면 태그 번호가 계속 같은 의미를 가지고 있기 때문에 새로운 코드가 예전 데이터를 항상 읽을 수 있음
- 하위 호환성을 유지하려면 새로운 필드를 추가하면 optional로 하거나 기본값을 가져야함
- 필드를 삭제할 때는 상/하위 호완성을 위해 optional 필드만 삭제하고 같은 태그 번호를 사용하지 않음

#### 1.4.2. 데이터타입과 스키마 발전
- 데이터 타입을 변경하는 것은 불가능하지는 않지만 값이 정확하지 않거나 잘릴 위험이 있음
- 32비트 정수에서 64비트 정수로 변경하면?
	- 파서가 누락된 비트를 0으로 채울 수 있음
	- 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있음
	- 새로운 코드가 기록한 데이터를 예전 코드가 읽는 경우 예전 코드는 값을 유지하기 위해 32비트 변수를 계속 사용하여 잘리게 됨
- 프로토콜 버퍼에는 목록이나 배열 데이터 타입이 없지만 repeated 표시자가 존재함
	- 레코드에 동일한 필드 태그가 여러번 나타남
	- optional 필드를 repeated 필드로 변경해도 문제가 없음
	- 이진 데이터를 읽는 새로운 코드는 0~1개의 엘리먼트가 있는 목록으로 보게 됨
	- 새로운 데이터를 읽는 예전 코드는 목록의 마지막 엘리먼트만 보게 됨 
		- 덮어 써지는 개념인듯
		- ~~뭐가 멋진 건지는 진짜 모름~~
- 스리프트에는 전용 목록 데이터 타입이 있음
	- 목록 엘리먼트의 데이터 타입을 매개변수로 받음
	- 단일 값에서 다중 값으로 변경을 허용하지 않지만 중첩된 목록을 지원한다는 장점이 있음

### 1.5. 아브로
- 아브로도 부호화할 데이터 구조를 지정하기 위해 스키마 사용
	- Avro IDL, JSON 기반
- 스키마에 태그 번호가 존재하지 않음
- 앞에 살펴본 모든 부호화 중 길이가 가장 짧음
- 데이터 타입을 식별하기 위한 정보가 없음
- 부호화는 단순히 연결된 값으로 구성됨
- 아브로를 이용해 이진 데이터를 파싱하려면 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터 타입을 미리 파악해야함
	- 읽는 코드가 기록한 코드와 정확히 같은 스키마를 사용하는 경우에만 이진 데이터를 올바르게 복호화할 수 있음을 의미
	- 읽기, 쓰기 스키마 불일치 시 복호화가 정확하지 않다는 의미

#### 1.5.1. 쓰기 스키마와 읽기 스키마
- 쓰기 스키마: 데이터를 아브로로 부호화할 때 알고 있는 스키마 버전을 사용해 데이터를 부호화
- 읽기 스키마: 데이터를 복호화할 때 데이터가 특정 스키마로 복호화하길 기대
- 어플리케이션 코드는 스키마에 의존함
- 복호화 코드는 애플리케이션을 빌드하는 동안 스키마로부터 생성됨
- 핵심 아이디어
	- 쓰기 스카마와 읽기 스키마가 동일하지 않아도 되며 호환만 가능하면 됨
	- 쓰기/읽기 스키마를 살펴본 다음 쓰기 스키마에서 읽기 스키마로 데이터를 변환해 그 차이를 해소
	- 필드 순서가 달라도 스키마 해석에서 이름으로 필드를 일치시키기 때문에 문제 없음
	- 데이터를 읽을 때 읽기 스키마에는 없고 쓰기 스키마에 존재하는 필드를 만나면 무시함
	- 읽기 스키마에 존재하지만 쓰기 스키마에 포함되어 있지 않은 필드는 읽기 스키마에 선언된 기본값으로 채움

#### 1.5.2. 스키마 발전 규칙
- 아브로의 상위 호환성: 새로운 버전의 쓰기 스키마와 예전 버전의 읽기 스키마를 가질 수 있음
- 아브로의 하위 호환성: 새로운 버전의 읽기 스키마와 예전 버전의 쓰기 스키마를 가질 수 있음
- 호환성을 유지하기 위해서는 기본값이 있는 필드만 추가, 삭제 가능
	- 새로운 스키마에 기본값이 있는 필드를 추가했다면 예전 스키마로 기록된 레코드를 읽으면 기본값으로 채워짐
- 기본값이 없는 필드를 추가하면 새로운 읽기는 에전 쓰기가 기록된 데이터를 읽을 수 없기 때문에 하위 호환성이 깨짐
	- 기본값이 없는 필드를 삭제하면 예전 읽기는 새로운 쓰기가 기록된 데이터를 읽을 수 없기 때문에 상위 호환성이 깨짐
- 필드에 null을 허용하여면 유니온 타입을 사용해야 함
	- 장황하지만 nullable, notnull을 명확하게 표현 가능
- 유니온 타입과 기본값 여부로 optional, required 표현 가능
- 필드의 데이터 타입 변경 가능
- 필드 이름도 변경 가능하지만 조금 까다로움
	- 읽기 스키마는 필드 이름의 별칭을 포함할 수 있고 이를 통해 스키마 필드 이름을 매치할 수 있음
	- 즉 필드 이름 변경은 하휘 호환성이 있지만 상위 호환성은 없다는 의미
- 유니온 타입 엘리먼트 추가하는 것도 하위 호환성은 있지만 상위 호환성은 없음

#### 1.5.3. 그러면 쓰기 스키마는 무엇인가?
- 읽기는 특정 데이터를 부호화한 쓰기 스키마를 어떻게 알 수 있을까?
- 모든 레코드에 전체 스키마를 포함시킬 수 없음
	- 스키마는 부호화된 데이터보다 훨씬 클 가능성이 있기 때문
- 예시
	- 많은 레코드가 있는 대용량 파일
		- 동일한 스키마로 부호화된 수백만 개 레코드를 포함한 큰 파일을 저장할 때 파일 시작 부분에 한 번만 쓰기 스키마를 포함 시킴
	- 개별적으로 기록된 레코드를 가진 데이터베이스
		- 부호화된 레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스에 스키마 버전 목옥을 유지
		- 레코드를 가져와 버전 번호를 추출하여 버전 번호에 해당하는 쓰기 스키마를 가져와서 남은 레코드를 복호화 함 
	- 네트워크 연결을 통해 레코드 보내기
		- 연결 설정에서 스키마 버전 합의 가능
		- 이후 연결을 유지하는 동안 합의된 스키마를 사용
		- Avro RPC

#### 1.5.4. 동적 생성 스키마
- 아브로 스키마는 스키마에 태그 번호가 포함되어 있지 않아 동적 생성 스키마에 더 친숙함
- 